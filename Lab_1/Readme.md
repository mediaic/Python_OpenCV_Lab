# Lab_1 
**What you will learn :**
 - Image Filtering
 - Image PCA & Classification 


**Directory Tree**
```
|__Lab1
|  |__ Readme.md
|  |__ Face_dataset/
|  |__ fig.jpg
```

**Requirement**

You can only use the python packages below:

 - numpy
 - cv2 (opencv)
 - matplotlib
 - sklearn
 - math

## Evaluation
For your output image, you could use eval.py to check your answer.
```
$ python3 eval.py --gt GT/1-1/fig_grad_x.jpg --out output/1-1/fig_grad_y.jpg
```
It will show that you "PASS!" or "FAIL." this question.

## 1. Image Filtering
1.	Load "**fig.jpg**" with **gray** scale.
2.	Compute and save the results of gradient generated by horizontal Sobel filter and vertical Sobel filter as **fig_grad_x.jpg** and **fig_grad_y.jpg** (with cv2.filter2D).
3.	Compute and save the gradient magnitude as **fig_grad_m.jpg** with the results in step 2.

## 2. Image PCA  Analysis
The dataset you need is under `Face_dataset/` directory, which contains 56×46 pixel face images of 40 different subjects (classes), and 10 images available for each subject. Note that, i_j.png means personi_imagej . Now you have to split the dataset into two subsets (i.e., training and test sets). The first subset contains the **first 6 images** of each subject, while the second subset include the remaining images. Thus, a total of 6 × 40 = 240 images are in the training set, while 160 images in the test set.

1. Perform PCA on the **training set**. Save the **mean face** and the first **three** eigenfaces.
	- save to [mean.png], [1.png], [2.png], [3.png]
	- Be careful the values in eigenvectors after PCA !  (*sklearn.decomposition.PCA*, you don't need to specify n_components value)
	- Bonus: you can implement your own PCA function !!
	- hint: 　255 * (shifted **x**/ max(shifted **x**))

2. Take **7_2.png**, and project it onto the above PCA eigenspace. Reconstruct this image using the first n = 3, 100 eigenfaces. For each n, compute the mean square error (MSE) between the reconstructed face image and **7_2.png**. Please save these reconstructed images , [7_2_n3.png] and [7_2_n100.png], and record the corresponding MSE values.

3. Apply the **k-nearest neighbors classifier** to recognize **test set** images. For simplicity, try k={1,3} and n = {3,100}.  Report the recognition rate on the test set with different (k,n) pairs.
	- hint: *sklearn.neighbors.KNeighborsClassifier()*


